# #####################################################################################GRABACIÓN#########################################################################################

# import naranja
# import torch
# import os
# import io
# import pandas as pd
# import pathlib
# import numpy as np
# import wx
# import time
# import threading
# import cv2
# import imutils
# import recording
# import rgb_video
# from ultralytics import YOLO
# import subprocess
# import recording

# from tracker import*
# from glob import glob
# from PIL import Image as im
# from torchvision.utils import draw_bounding_boxes
# from IPython.display import Image, display


# ####################################
# # Class NaranjasFrame
# ####################################

# class naranjasFrameImpl (naranja.naranjaFrame):

#     def __init__(self, parent):
#         super().__init__(parent)
#         #self.bitmap = wx.StaticBitmap(self.bitmapPanel)
#         #self.animation = wx.AnimationCtrl(self.bitmapPanel)
#         self.detectButton.Bind(wx.EVT_BUTTON, self.iniciarProceso)
#         self.grabacionButton.Bind(wx.EVT_BUTTON, self.grabacionProceso)
#         self.tracker=Tracker()
#         self.detenerButton 

# ############Variables###############

#         self.count=0
#         self.cy1=100
#         self.cy2=300
#         self.cy3=500
#         self.offset=10
#         self.oran_pass={}
#         self.counter1 = set()
#         self.counter2 = set()
#         self.counter3 = set()
#         self.estimacion = 0
#         self.long1 = 0
#         self.long2 = 0
#         self.long3 = 0

# #############Recording##############

#     def grabacionProceso(self, event):
#         self.grabacionButton.Disable()
#         self.quitRecording = threading.Event()
#         self.thread = threading.Thread(target= self.recording, args=[self.quitRecording])
#         self.thread.start()

#     def recording(self, threadEvent):
#         recording.run(threadEvent)
        
#     def stopRecording(self):
#         self.quitRecording.set()
#         self.grabacionButton.Enable()

# ####################################

#     def iniciarProceso(self, event):
#         self.detectButton.Disable()
#         self.thread = threading.Thread(target=self.detectarRecortar)
#         self.thread.start()

#     def cargaModelo(self):
#         model=YOLO(r'D:\NaranjasFinal\Interfaz\yolov8n_custom20\weights\best.pt')
#         return model

#     def seleccionaCarpeta(self):
#         path= self.filePickerButton.GetPath() #Elegir carpeta
#         #path = r"D:/NaranjasFinal/Interfaz/Divisiones" #Carpeta
#         return os.path.join(path)

#     def capturarVideo(self):
#         cap=cv2.VideoCapture(self.seleccionaCarpeta())
#         #cap = cv2.VideoCapture(rgb_video.run())
#         return cap
    
#     def detectar(self):
#         self.counter1.clear()
#         self.counter2.clear()
#         self.counter3.clear()
#         self.medidasText.Clear()
#         self.estimaciontextCtrl.Clear()
#         self.medidasText.AppendText("Cargando Video...   ")
#         modelo = self.cargaModelo()
#         cap = self.capturarVideo()

#         count = self.count
#         cy1 = self.cy1
#         cy2 = self.cy2
#         cy3 = self.cy3
#         offset = self.offset
#         oran_pass = self.oran_pass
#         counter1 = self.counter1
#         counter2 = self.counter2
#         counter3 = self.counter3
#         estimacion = self.estimacion
#         long1 = self.long1
#         long2 = self.long2
#         long3 = self.long3

#         while True:    
#             ret,frame = cap.read()
#             if not ret:
#                 break
#             count += 1
#             if count % 3 != 0:
#                 continue

#             frame = imutils.resize(frame,width=600)
#             class_list = modelo.names
#             results=modelo.predict(frame)
#             results[0].conf = 0.35

#             a=results[0].boxes.data.cpu()
#             px=pd.DataFrame(a).astype("float")
#             #print(px)
#             list=[]
                    
#             for index,row in px.iterrows():
        
#                 x1=int(row[0])
#                 y1=int(row[1])
#                 x2=int(row[2])
#                 y2=int(row[3])
#                 d=int(row[5])
#                 c=class_list[d]
#                 if 'Naranja' in c:
#                     list.append([x1,y1,x2,y2])

#             bbox_id=self.tracker.update(list)
#             for bbox in bbox_id:
#                 x3,y3,x4,y4,id=bbox
#                 cx=int(x3+x4)//2
#                 cy=int(y3+y4)//2
#                 cv2.rectangle(frame, (x3,y3), (x4,y4), (0, 0, 255), 2)

#                 if cy1<(cx+offset) and cy1> (cx-offset):
#                     oran_pass[id] = cx
#                     cv2.circle(frame,(cx,cy),4,(0,0,255),-1)
#                     cv2.putText(frame,str(id),(cx,cy),cv2.FONT_HERSHEY_COMPLEX,0.8,(0,255,255),2)
#                     counter1.add(id)
#                     long1 = len(counter1)

#                 if cy2<(cx+offset) and cy2> (cx-offset):
#                     oran_pass[id] = cx
#                     cv2.circle(frame,(cx,cy),4,(0,0,255),-1)
#                     cv2.putText(frame,str(id),(cx,cy),cv2.FONT_HERSHEY_COMPLEX,0.8,(0,255,255),2)
#                     counter2.add(id)
#                     long2 = len(counter2)

#                 if cy3<(cx+offset) and cy3> (cx-offset):
#                     oran_pass[id] = cx
#                     cv2.circle(frame,(cx,cy),4,(0,0,255),-1)
#                     cv2.putText(frame,str(id),(cx,cy),cv2.FONT_HERSHEY_COMPLEX,0.8,(0,255,255),2)       
#                     counter3.add(id)
                    
#                     long3 = len(counter3)

#                 # cv2.line(frame,(cy1, 325), (cy1, 10),(255,255,255),1)
#                 # cv2.line(frame,(cy2, 325), (cy2, 10),(255,255,255),1)
#                 # cv2.line(frame,(cy3, 325), (cy3, 10),(255,255,255),1)
#                 cv2.line(frame,(cy1, 1500), (cy1, 10),(255,255,255),1)
#                 cv2.line(frame,(cy2, 1500), (cy2, 10),(255,255,255),1)
#                 cv2.line(frame,(cy3, 1500), (cy3, 10),(255,255,255),1)
#                 # cv2.line(frame,(cy1, 725), (cy1, 10),(255,255,255),1)
#                 # cv2.line(frame,(cy2, 725), (cy2, 10),(255,255,255),1)
#                 # cv2.line(frame,(cy3, 725), (cy3, 10),(255,255,255),1)

#             # bitmap = wx.StaticBitmap(self.bitmapPanel, wx.ID_ANY, wx.Bitmap(frame))
#             # bitmap = wx.AnimationCtrl
#             # bitmap.SetPosition((0,0))

#             estimacion = (long1 + long2 + long3)/3
#             estimacion = int(estimacion)
#             self.estimaciontextCtrl.SetValue(f'Linea1:  {long1}\nLinea2:  {long2}\nLinea3:  {long3}\n' + 'Estimación: ' + str(estimacion))    
#             cv2.putText(frame, ('Naranjas: ') + str(estimacion), (cy1, 50), cv2.FONT_ITALIC, 0.8, (0, 255, 255), 2)
#             cv2.imshow("RGB", frame)
#             if cv2.waitKey(1)&0xFF==27:
#                 break
        
#         cap.release()
#         cv2.destroyAllWindows()
#         os.makedirs("D:/NaranjasFinal/Interfaz/Datos/", exist_ok=True)
#         path = 'D:/NaranjasFinal/Interfaz/Datos/Estimacion.xlsx'
#         df = pd.DataFrame({'Estimacion 1' : [long1],
#                            'Estimacion 2' : [long2],
#                            'Estimacion 3' : [long3],
#                            'Estimacion Final' : [estimacion],})
        
#         if os.path.exists(path):
#             df_existe = pd.read_excel(path)
#             df = pd.concat([df_existe, df], ignore_index=True)
        
#         df.to_excel(path,index=False)

#         #wx.CallAfter(self.bitmap.SetBitmap, frame)
#         wx.CallAfter(self.detectButton.Enable)
#         self.medidasText.AppendText("Finalizado.")

    


# ###################################
# # Botones Main
# ###################################

#     def detectarRecortar(self):
#         self.detectar()

#     # def stopButtonFunc(self, event):
#     #     if cv2.waitKey(1) == ord('q'):
#     #             break

#     def grabacionFunction(self, event):
#         self.recording()     
    
#     def grabacionStopFunction(self, event):
#         self.stopRecording()

#     def closeFunc(self, event):
#         self.Close()

# ###################################









# #####################################################################################TIEMPO REAL#########################################################################################


import naranja
import os
import pandas as pd
import wx
import threading
import cv2
#import recording
import torch
from ultralytics import YOLO
#import depthai as dai
import imutils
from tracker import*
from glob import glob
from torchvision.utils import draw_bounding_boxes
#from IPython.display import Image, display


####################################
# Class NaranjasFrame
####################################

class naranjasFrameImpl (naranja.naranjaFrame):

    def __init__(self, parent):
        super().__init__(parent)
        self.detectButton.Bind(wx.EVT_BUTTON, self.iniciarProcesoDetectar)
        #self.stopButton.Bind(wx.EVT_BUTTON, self.iniciarProcesoStop)
        self.closeButton.Enable()
        #self.grabacionButton.Bind(wx.EVT_BUTTON, self.grabacionProceso)
        self.tracker=Tracker()
        self.detenerButton
        self.stopVideoFlag = False        
############Variables###############

        self.count=0
        self.cy1=200
        self.cy2=525
        self.cy3=850
        self.offset=10
        self.oran_pass={}
        self.counter1 = set()
        self.counter2 = set()
        self.counter3 = set()
        self.estimacion = 0
        self.long1 = 0
        self.long2 = 0
        self.long3 = 0


#############Recording##############

    # def grabacionProceso(self, event):
    #     self.grabacionButton.Disable()
    #     self.quitRecording = threading.Event()
    #     self.thread = threading.Thread(target= self.recording, args=[self.quitRecording])
    #     self.thread.start()

    # def recording(self, threadEvent):
    #     recording.run(threadEvent)
        
    # def stopRecording(self):
    #     self.quitRecording.set()
    #     self.grabacionButton.Enable()

####################################

    def iniciarProcesoDetectar(self, event):
        self.detectButton.Disable()
        self.thread = threading.Thread(target=self.detectarRecortar)
        self.thread.start()

    # def iniciarProcesoStop(self, event):
    #     self.stopButton.Disable()
    #     self.thread = threading.Thread(target=self.stopButtonFunc)
    #     self.thread.start()

    def capturarVideo(self):
        #cap = cv2.VideoCapture(self.seleccionaCarpeta())
        #cap = "/home/ivia/Desktop/inter/Interfaz/NaranjasPano.mp4"
        # cap = cv2.VideoCapture(cap)

        flip=0 # identity - no rotation (default)
        # flip=1 # counterclockwise - 90 degrees
        # flip=2 # rotate - 180 degrees
        # flip=3 # clockwise - 90 degrees
        # flip=4 # horizontal flip
        # flip=5 # upper right diagonal flip
        # flip=6 # vertical flip
        # flip=7 # upper-left diagonal
        #cap = f'nvarguscamerasrc sensor-id=0 ! video/x-raw(memory:NVMM),width=1920,height=1080,framerate=21/1,format=NV12 ! nvvidconv flip-method={flip} ! video/x-raw,width=1920,height=1080,format=BGRx ! videoconvert ! video/x-raw,format=BGR ! queue ! appsink'
        cap = f'nvarguscamerasrc sensor-id=0 ! video/x-raw(memory:NVMM),width=1920,height=1080,framerate=21/1,format=NV12 ! nvvidconv flip-method={flip} ! videoconvert ! video/x-raw,format=BGR ! queue ! appsink'
        cap = cv2.VideoCapture(cap)

        return cap

    def stopVideo(self):
        
        if self.stopVideoFlag == True:
            self.closeButton.Enable()
            return self.stopVideoFlag

    def cargaModelo(self):
        torch.cuda.set_device(0)
        model=YOLO(r'/home/ivia/Desktop/inter/yolov8n_custom12/weights/best.pt')
        return model
    
    def detectar(self):
        self.counter1.clear()
        self.counter2.clear()
        self.counter3.clear()
        self.medidasText.Clear()
        self.estimaciontextCtrl.Clear()
        self.medidasText.AppendText("Cargando Video...   ")
        modelo = self.cargaModelo().cuda()
        print(f'modelo.device = {modelo.device}')
        cap = self.capturarVideo()
        #cap = self.recording()

        count = self.count
        cy1 = self.cy1
        cy2 = self.cy2
        cy3 = self.cy3
        offset = self.offset
        oran_pass = self.oran_pass
        counter1 = self.counter1
        counter2 = self.counter2
        counter3 = self.counter3
        estimacion = self.estimacion
        long1 = self.long1
        long2 = self.long2
        long3 = self.long3
        print("Reading capture device.")

        while True:    
            ret,frame = cap.read()

            if not ret:
                break
            count += 1
            if count % 3 != 0:
                continue

            frame = imutils.resize(frame,width=300)
            class_list = modelo.names
            print(f"Prediccion... (tipo={type(frame)})")

            results=modelo.predict(frame)
            results[0].conf = 0.35
            print("Results")

            a=results[0].boxes.data.cpu()
            px=pd.DataFrame(a).astype("float")
            #print(px)
            list=[]
                    
            for index,row in px.iterrows():
        
                x1=int(row[0])
                y1=int(row[1])
                x2=int(row[2])
                y2=int(row[3])
                d=int(row[5])
                c=class_list[d]
                if 'Naranja' in c:
                    list.append([x1,y1,x2,y2])

            bbox_id=self.tracker.update(list)
            for bbox in bbox_id:
                x3,y3,x4,y4,id=bbox
                cx=int(x3+x4)//2
                cy=int(y3+y4)//2
                cv2.rectangle(frame, (x3,y3), (x4,y4), (0, 0, 255), 2)

                if cy1<(cx+offset) and cy1> (cx-offset):
                    oran_pass[id] = cx
                    cv2.circle(frame,(cx,cy),4,(0,0,255),-1)
                    cv2.putText(frame,str(id),(cx,cy),cv2.FONT_HERSHEY_COMPLEX,0.8,(0,255,255),2)
                    counter1.add(id)
                    long1 = len(counter1)

                if cy2<(cx+offset) and cy2> (cx-offset):
                    oran_pass[id] = cx
                    cv2.circle(frame,(cx,cy),4,(0,0,255),-1)
                    cv2.putText(frame,str(id),(cx,cy),cv2.FONT_HERSHEY_COMPLEX,0.8,(0,255,255),2)
                    counter2.add(id)
                    long2 = len(counter2)

                if cy3<(cx+offset) and cy3> (cx-offset):
                    oran_pass[id] = cx
                    cv2.circle(frame,(cx,cy),4,(0,0,255),-1)
                    cv2.putText(frame,str(id),(cx,cy),cv2.FONT_HERSHEY_COMPLEX,0.8,(0,255,255),2)       
                    counter3.add(id)
                    
                    long3 = len(counter3)

                cv2.line(frame,(cy1, 1000), (cy1, 50),(255,255,255),1)
                cv2.line(frame,(cy2, 1000), (cy2, 50),(255,255,255),1)
                cv2.line(frame,(cy3, 1000), (cy3, 50),(255,255,255),1)

            # bitmap = wx.StaticBitmap(self.bitmapPanel, wx.ID_ANY, wx.Bitmap(frame))
            # bitmap = wx.AnimationCtrl
            # bitmap.SetPosition((0,0))

            estimacion = (long1 + long2 + long3)/3
            estimacion = int(estimacion)
            self.estimaciontextCtrl.SetValue(f'Linea1:  {long1}\nLinea2:  {long2}\nLinea3:  {long3}\n' + 'Estimación: ' + str(estimacion))    
            cv2.putText(frame, ('Naranjas: ') + str(estimacion), (cy1, 50), cv2.FONT_ITALIC, 0.8, (0, 255, 255), 2)
            #print(type(frame.dtype))
            #print(frame.shape)
            #f = plt.figure()
            #im = plt.imshow(frame)#[:,:,::-1]
            #f.show()
            cv2.imshow("RGB", frame)
            #if cv2.waitKey(1)&0xFF==27:
            #    break
        


        cap.release()
#        cv2.destroyAllWindows()
        #plt.close()
        os.makedirs("/home/ivia/Desktop/inter/Datos/", exist_ok=True) #/home/ivia/Desktop/inter/Interfaz/Datos/
        path = '/home/ivia/Desktop/inter/Datos/Estimacion.xlsx'
        df = pd.DataFrame({'Estimacion 1' : [long1],
                           'Estimacion 2' : [long2],
                           'Estimacion 3' : [long3],
                           'Estimacion Final' : [estimacion],})
        
        if os.path.exists(path):
            df_existe = pd.read_excel(path)
            df = pd.concat([df_existe, df], ignore_index=True)
        
        df.to_excel(path,index=False)

        #wx.CallAfter(self.bitmap.SetBitmap, frame)
        wx.CallAfter(self.detectButton.Enable)
        self.medidasText.AppendText("Finalizado.")


###################################
# Botones Main
###################################

    def detectarRecortar(self):
        self.detectar()

    def stopButtonFunc(self, event):
        self.stopVideoFlag = True
        self.stopVideo()

    def grabacionFunction(self, event):
        self.recording()     
    
    def grabacionStopFunction(self, event):
        self.stopRecording()

    def closeFunc(self, event):
        self.Close()

###################################



import naranja
# import torch
# import os
# import io
# import pandas as pd
# import pathlib
# import numpy as np
# import wx
# import time
# import threading
# import cv2
# import imutils
# from ultralytics import YOLO
# import subprocess
# #import recording
# import recordVideo
# #import matplotlib.pyplot as plt

# from tracker import*
# from glob import glob
# from PIL import Image as im
# from torchvision.utils import draw_bounding_boxes
# from IPython.display import Image, display


# ####################################
# # Class NaranjasFrame
# ####################################

# class naranjasFrameImpl (naranja.naranjaFrame):

#     def __init__(self, parent):
#         super().__init__(parent)
#         #self.bitmap = wx.StaticBitmap(self.bitmapPanel)
#         #self.animation = wx.AnimationCtrl(self.bitmapPanel)
#         #self.detectButton.Bind(wx.EVT_BUTTON, self.iniciarProceso)
#         #self.detectButton.Bind(wx.EVT_BUTTON, self.detectar)
#         #self.grabacionButton.Bind(wx.EVT_BUTTON, self.grabacionProceso)
#         self.tracker=Tracker()
#         self.detenerButton 

# ############Variables###############

#         self.count=0
#         self.cy1=100
#         self.cy2=300
#         self.cy3=500
#         self.offset=10
#         self.oran_pass={}
#         self.counter1 = set()
#         self.counter2 = set()
#         self.counter3 = set()
#         self.estimacion = 0
#         self.long1 = 0
#         self.long2 = 0
#         self.long3 = 0

# #############Recording##############

#     # def grabacionProceso(self, event):
#     #     self.grabacionButton.Disable()
#     #     self.quitRecording = threading.Event()
#     #     self.thread = threading.Thread(target= self.recording, args=[self.quitRecording])
#     #     self.thread.start()

#     # def recording(self, threadEvent):
#     #     recording.run(threadEvent)
        
#     # def stopRecording(self):
#     #     self.quitRecording.set()
#     #     self.grabacionButton.Enable()


#     def recording(self):
#         recordVideo.read_cam()

    
#         # flip=0 # identity - no rotation (default)
#         # # flip=1 # counterclockwise - 90 degrees
#         # # flip=2 # rotate - 180 degrees
#         # # flip=3 # clockwise - 90 degrees
#         # # flip=4 # horizontal flip
#         # # flip=5 # upper right diagonal flip
#         # # flip=6 # vertical flip
#         # # flip=7 # upper-left diagonal
#         # camSet = f'nvarguscamerasrc sensor-id=0 ! video/x-raw(memory:NVMM),width=1920,height=1080,framerate=21/1,format=NV12 ! nvvidconv flip-method={flip} ! video/x-raw,width=1920,height=1080,format=BGRx ! videoconvert ! video/x-raw,format=BGR ! queue ! appsink'
        

# ####################################

#     # def iniciarProceso(self, event):
#     #     self.detectButton.Disable()
#     #     self.thread = threading.Thread(target=self.detectarRecortar)
#     #     self.thread.start()

#     def cargaModelo(self):
#         model=YOLO(r'/home/ivia/Desktop/inter/yolov8n_custom12/weights/best.pt')
#         return model

#     def seleccionaCarpeta(self):
#         #path= self.filePickerButton.GetPath() #Elegir carpeta
#         path ="/home/ivia/Desktop/inter/Interfaz/NaranjasPano.mp4"
#         #path = r"D:/NaranjasFinal/Interfaz/Divisiones" #Carpeta
#         #return os.path.join(path)
#         return path

#     def capturarVideo(self):
#         #cap = cv2.VideoCapture(self.seleccionaCarpeta())
#         #cap = "/home/ivia/Desktop/inter/Interfaz/NaranjasPano.mp4"
#         # cap = cv2.VideoCapture(cap)

#         flip=0 # identity - no rotation (default)
#         # flip=1 # counterclockwise - 90 degrees
#         # flip=2 # rotate - 180 degrees
#         # flip=3 # clockwise - 90 degrees
#         # flip=4 # horizontal flip
#         # flip=5 # upper right diagonal flip
#         # flip=6 # vertical flip
#         # flip=7 # upper-left diagonal
#         cap = f'nvarguscamerasrc sensor-id=0 ! video/x-raw(memory:NVMM),width=1920,height=1080,framerate=21/1,format=NV12 ! nvvidconv flip-method={flip} ! video/x-raw,width=1920,height=1080,format=BGRx ! videoconvert ! video/x-raw,format=BGR ! queue ! appsink'
#         cap = cv2.VideoCapture(cap)

#         return cap
    
#     def detectar(self):
#         self.counter1.clear()
#         self.counter2.clear()
#         self.counter3.clear()
#         self.medidasText.Clear()
#         self.estimaciontextCtrl.Clear()
#         self.medidasText.AppendText("Cargando Video...   ")
#         modelo = self.cargaModelo().cuda()
#         print(f'modelo.device = {modelo.device}')
#         cap = self.capturarVideo()
#         #cap = self.recording()

#         count = self.count
#         cy1 = self.cy1
#         cy2 = self.cy2
#         cy3 = self.cy3
#         offset = self.offset
#         oran_pass = self.oran_pass
#         counter1 = self.counter1
#         counter2 = self.counter2
#         counter3 = self.counter3
#         estimacion = self.estimacion
#         long1 = self.long1
#         long2 = self.long2
#         long3 = self.long3

#         while True:    
#             ret,frame = cap.read()
#             if not ret:
#                 break
#             count += 1
#             if count % 3 != 0:
#                 continue

#             frame = imutils.resize(frame,width=600)
#             class_list = modelo.names

#             results=modelo.predict(frame)
#             results[0].conf = 0.35

#             a=results[0].boxes.data.cpu()
#             px=pd.DataFrame(a).astype("float")
#             #print(px)
#             list=[]
                    
#             for index,row in px.iterrows():
        
#                 x1=int(row[0])
#                 y1=int(row[1])
#                 x2=int(row[2])
#                 y2=int(row[3])
#                 d=int(row[5])
#                 c=class_list[d]
#                 if 'Naranja' in c:
#                     list.append([x1,y1,x2,y2])

#             bbox_id=self.tracker.update(list)
#             for bbox in bbox_id:
#                 x3,y3,x4,y4,id=bbox
#                 cx=int(x3+x4)//2
#                 cy=int(y3+y4)//2
#                 cv2.rectangle(frame, (x3,y3), (x4,y4), (0, 0, 255), 2)

#                 if cy1<(cx+offset) and cy1> (cx-offset):
#                     oran_pass[id] = cx
#                     cv2.circle(frame,(cx,cy),4,(0,0,255),-1)
#                     cv2.putText(frame,str(id),(cx,cy),cv2.FONT_HERSHEY_COMPLEX,0.8,(0,255,255),2)
#                     counter1.add(id)
#                     long1 = len(counter1)

#                 if cy2<(cx+offset) and cy2> (cx-offset):
#                     oran_pass[id] = cx
#                     cv2.circle(frame,(cx,cy),4,(0,0,255),-1)
#                     cv2.putText(frame,str(id),(cx,cy),cv2.FONT_HERSHEY_COMPLEX,0.8,(0,255,255),2)
#                     counter2.add(id)
#                     long2 = len(counter2)

#                 if cy3<(cx+offset) and cy3> (cx-offset):
#                     oran_pass[id] = cx
#                     cv2.circle(frame,(cx,cy),4,(0,0,255),-1)
#                     cv2.putText(frame,str(id),(cx,cy),cv2.FONT_HERSHEY_COMPLEX,0.8,(0,255,255),2)       
#                     counter3.add(id)
                    
#                     long3 = len(counter3)

#                 cv2.line(frame,(cy1, 1000), (cy1, 50),(255,255,255),1)
#                 cv2.line(frame,(cy2, 1000), (cy2, 50),(255,255,255),1)
#                 cv2.line(frame,(cy3, 1000), (cy3, 50),(255,255,255),1)

#             # bitmap = wx.StaticBitmap(self.bitmapPanel, wx.ID_ANY, wx.Bitmap(frame))
#             # bitmap = wx.AnimationCtrl
#             # bitmap.SetPosition((0,0))

#             estimacion = (long1 + long2 + long3)/3
#             estimacion = int(estimacion)
#             self.estimaciontextCtrl.SetValue(f'Linea1:  {long1}\nLinea2:  {long2}\nLinea3:  {long3}\n' + 'Estimación: ' + str(estimacion))    
#             cv2.putText(frame, ('Naranjas: ') + str(estimacion), (cy1, 50), cv2.FONT_ITALIC, 0.8, (0, 255, 255), 2)
#             #print(type(frame.dtype))
#             #print(frame.shape)
#             #f = plt.figure()
#             #im = plt.imshow(frame)#[:,:,::-1]
#             #f.show()
#             cv2.imshow("RGB", frame)
#             #if cv2.waitKey(1)&0xFF==27:
#             #    break
        


#         cap.release()
# #        cv2.destroyAllWindows()
#         #plt.close()
#         os.makedirs("/home/ivia/Desktop/inter/Interfaz/Datos/", exist_ok=True) #/home/ivia/Desktop/inter/Interfaz/Datos/
#         path = '/home/ivia/Desktop/inter/Interfaz/Datos/Estimacion.xlsx'
#         df = pd.DataFrame({'Estimacion 1' : [long1],
#                            'Estimacion 2' : [long2],
#                            'Estimacion 3' : [long3],
#                            'Estimacion Final' : [estimacion],})
        
#         if os.path.exists(path):
#             df_existe = pd.read_excel(path)
#             df = pd.concat([df_existe, df], ignore_index=True)
        
#         df.to_excel(path,index=False)

#         #wx.CallAfter(self.bitmap.SetBitmap, frame)
#         wx.CallAfter(self.detectButton.Enable)
#         self.medidasText.AppendText("Finalizado.")


    
# ###################################
# # Botones Main
# ###################################

#     def grabacionFunction(self, event):
#         self.recording()

#     # def detectarRecortar(self):
#     #     self.detectar()
  
#     def detectFunction(self, event): 
#         self.detectar()

#     def closeFunc(self, event):
#         self.Close()
    
#     def grabacionStopFunction(self, event):
#         self.stopRecording()

# ###################################
